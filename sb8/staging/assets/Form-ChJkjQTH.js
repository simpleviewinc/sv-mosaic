import{j as e}from"./jsx-runtime-EKYJJIwR.js";import{useMDXComponents as s}from"./index-BwDDMXeo.js";import{M as r}from"./index-BdEBlvtF.js";import{s as d}from"./Playground.stories-cm4pwfPT.js";import"./index-D0AnReJb.js";import"./iframe-IVYvR9di.js";import"../sb-preview/runtime.js";import"./index-Bqzh3Cp6.js";import"./index-SI8xS9YR.js";import"./tslib.es6-CvpyDmub.js";import"./index-Cu4lwwaE.js";import"./extends-CF3RwP-h.js";import"./inheritsLoose-CMy1E8oj.js";import"./toString-DoexKoos.js";import"./_baseForOwn-YgwlavHx.js";import"./index-QVqIEGA1.js";import"./_arrayIncludesWith-XJRwRZaz.js";import"./index-DrFu-skq.js";import"./index.browser-vcSNLBTf.js";import"./options-DEOzrsxm.js";import"./numberTable-_IOpZUZY.js";import"./index-0j0SjakP.js";import"./sizes-BklZZmo4.js";import"./testIds-Dso8kRSM.js";import"./TitleWrapper-BVBDXDWY.js";import"./Button-DWbCZful.js";import"./generateUtilityClasses-rDn4KRfY.js";import"./ButtonBase-C5QWJNfJ.js";import"./useIsFocusVisible-CvEUtp4E.js";import"./Popper-BwE5duTX.js";import"./ownerWindow-DvT1GKkC.js";import"./createChainedFunction-BO_9K8Jh.js";import"./useTheme-D7dAzrtf.js";import"./useToggle-CTbnrs6g.js";import"./containerQuery-CZARXB1J.js";import"./createSvgIcon-BLTtL5Y9.js";import"./createSvgIcon-Dg0jtXvj.js";import"./useId-BgzzDjMB.js";import"./useControlled-DuXZYv4M.js";import"./Typography-iddL5eaH.js";import"./TitleText-CICG0G5h.js";import"./ButtonRow-BOELw1Tj.js";import"./index-5FtVc0ZK.js";import"./debounce-D-BUC-g1.js";import"./DataViewPrimaryFilter.styled-BizDTt4x.js";import"./Chip-CMTBWucu.js";import"./useMosaicTranslation-CoWLI8L7.js";import"./FormFieldText.styled-CGYIYrSS.js";import"./formControlState-BAKA1Iy6.js";import"./Spinner-CbDJlIED.js";import"./SubtitleText-DS-qVyZH.js";import"./CheckboxList-BfityfDx.js";import"./Checkbox-CpLxzsg0.js";import"./FormControlLabel-BKc7O7Lz.js";import"./MoreVert-CMcGX8SU.js";import"./ChevronRight-BydWUgoJ.js";import"./PageHeader-DhpZ4BIu.js";import"./formats-CMvQHWsT.js";import"./RadioButton-p7gSMkH6.js";import"./StyledFormControl.styled-BMW4FUOw.js";import"./Toggle-9YEwDS0M.js";import"./Dialog-CnKRaqxG.js";import"./ChipList-DGWZ9ZdD.js";import"./SideNav-kqb59Ukq.js";import"./Snackbar-CMDie7lV.js";import"./Close-DQPzhJmS.js";import"./ClickAwayListener-Dkkr5f_-.js";import"./renderButtons-BmHfsf_z.js";import"./dom-BR2PSRFh.js";function i(t){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...s(),...t.components};return e.jsxs(e.Fragment,{children:[e.jsx(r,{of:d}),`
`,e.jsx(n.h1,{id:"form",children:"Form"}),`
`,e.jsxs(n.p,{children:[e.jsx(n.code,{children:"Form"})," is a solution to help all SimpleView products using Mosaic standardise both styling and functionality of forms and the fields within. It comes pre-filled with multiple generic stylised and functional fields so you can focus on your app's functionality and not how to make a form work."]}),`
`,e.jsx(n.h4,{id:"on-this-page",children:"On this page"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsxs(n.li,{children:[e.jsx(n.a,{href:"#hook-useform",children:"Hook: useForm"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsx(n.li,{children:e.jsxs(n.a,{href:"#interface-useformparams",children:["Interface: ",e.jsx(n.code,{children:"UseFormParams"})]})}),`
`,e.jsx(n.li,{children:e.jsxs(n.a,{href:"#interface-formcontroller",children:["Interface: ",e.jsx(n.code,{children:"FormController"})]})}),`
`,e.jsxs(n.li,{children:[e.jsx(n.a,{href:"#the-form-state",children:"The Form State"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsx(n.li,{children:e.jsxs(n.a,{href:"#interface-formstate",children:["Interface: ",e.jsx(n.code,{children:"FormState"})]})}),`
`]}),`
`]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.a,{href:"#manipulating-the-form",children:"Manipulating the Form"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsx(n.li,{children:e.jsxs(n.a,{href:"#interface-formmethods",children:["Interface: ",e.jsx(n.code,{children:"FormMethods"})]})}),`
`]}),`
`]}),`
`]}),`
`]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.a,{href:"#component-form",children:"Component: Form"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsx(n.li,{children:e.jsxs(n.a,{href:"#interface-formprops",children:["Interface: ",e.jsx(n.code,{children:"FormProps"})]})}),`
`]}),`
`]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.a,{href:"#basic-usage",children:"Basic Usage"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsxs(n.li,{children:[e.jsx(n.a,{href:"#submission",children:"Submission"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsx(n.li,{children:e.jsx(n.a,{href:"#external-submission",children:"External Submission"})}),`
`]}),`
`]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.a,{href:"#prepopulated-values",children:"Prepopulated Values"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsx(n.li,{children:e.jsx(n.a,{href:"#synchronous-population",children:"Synchronous population"})}),`
`,e.jsx(n.li,{children:e.jsx(n.a,{href:"#asynchronous-population",children:"Asynchronous population"})}),`
`]}),`
`]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.a,{href:"#layout",children:"Layout"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsx(n.li,{children:e.jsxs(n.a,{href:"#interface-sectiondef",children:["Interface: ",e.jsx(n.code,{children:"SectionDef"})]})}),`
`]}),`
`]}),`
`]}),`
`]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.a,{href:"#form-fields",children:"Form Fields"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsx(n.li,{children:e.jsxs(n.a,{href:"#interface-fielddef",children:["Interface: ",e.jsx(n.code,{children:"FieldDef"})]})}),`
`,e.jsx(n.li,{children:e.jsx(n.a,{href:"#built-in-field-types",children:"Built-in Field Types"})}),`
`,e.jsxs(n.li,{children:[e.jsx(n.a,{href:"#smart-validation",children:"Smart Validation"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsx(n.li,{children:e.jsx(n.a,{href:"#validators",children:"Validators"})}),`
`]}),`
`]}),`
`]}),`
`]}),`
`]}),`
`,e.jsxs(n.p,{children:["The ",e.jsx(n.code,{children:"Form"})," component should be used in conjunction with the ",e.jsx(n.code,{children:"useForm"})," hook which provides a form controller instance for the form and its fields to work with. The form controller contains a number of methods that can be used to manipulate the state of the form as well as the state object itself to provide a way of performing side effects based on changes."]}),`
`,e.jsx(n.h2,{id:"hook-useform",children:"Hook: useForm"}),`
`,e.jsxs(n.p,{children:["Invoking ",e.jsx(n.code,{children:"useForm"})," returns an object that implements the ",e.jsx(n.code,{children:"FormController"})," interface. The properties of the form controller should be spread into the ",e.jsx(n.code,{children:"Form"})," component. The ",e.jsx(n.code,{children:"useForm"})," hook accepts a single parameter that meets the ",e.jsx(n.code,{children:"UseFormParams"})," contract."]}),`
`,e.jsx(n.h4,{id:"interface-useformparams",children:"Interface: UseFormParams"}),`
`,e.jsxs(n.table,{children:[e.jsx(n.thead,{children:e.jsxs(n.tr,{children:[e.jsx(n.th,{children:"Name"}),e.jsx(n.th,{children:"Type"}),e.jsx(n.th,{children:"Description"})]})}),e.jsxs(n.tbody,{children:[e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"data"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"any"})}),e.jsxs(n.td,{children:["The form values to be provided as initial ",e.jsx(n.code,{children:"data"})," state."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"skeleton"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"boolean"})}),e.jsxs(n.td,{children:['Whether or not the form should be initially rendered in a "skeletonized" state. This value would likely be ',e.jsx(n.code,{children:"true"})," if you intend to asynchronously load form data after the form has rendered."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"disabled"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"boolean"})}),e.jsxs(n.td,{children:["Whether or not the form should be initially rendered in a disabled state. This value would likely be ",e.jsx(n.code,{children:"true"})," if you intend to asynchronously load form data after the form has rendered."]})]})]})]}),`
`,e.jsx(n.h4,{id:"interface-formcontroller",children:"Interface: FormController"}),`
`,e.jsxs(n.table,{children:[e.jsx(n.thead,{children:e.jsxs(n.tr,{children:[e.jsx(n.th,{children:"Name"}),e.jsx(n.th,{children:"Type"}),e.jsx(n.th,{children:"Description"})]})}),e.jsxs(n.tbody,{children:[e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"state"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"FormState"})}),e.jsxs(n.td,{children:["Contains all of the form state. You can use this to perform side effects. ",e.jsx(n.code,{children:"state"})," is described in more detail below."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"methods"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"FormMethods"})}),e.jsxs(n.td,{children:["Contains all of the methods necessary for manipulating form state. ",e.jsx(n.code,{children:"methods"})," is described in more detail below."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"handleSubmit"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"(onSuccess: OnSubmitSuccess, onError?: OnSubmitError) => () => Promise<void>"})}),e.jsxs(n.td,{children:[e.jsx(n.code,{children:"handleSubmit"})," is a higher order function available on the form controller and should be used to wrap a callback to be invoked on a successful submission. ",e.jsx(n.code,{children:"handleSubmit"})," accepts an optional second callback to be invoked on an invalid submission. Both callbacks will be invoked with an object containing at least the ",e.jsx(n.code,{children:"data"})," property - this will contain the form data. The parameter provided to the success handler will have an additional property: ",e.jsx(n.code,{children:"activeFields"})," will contain a list of field names that are considered active."]})]})]})]}),`
`,e.jsx(n.h3,{id:"the-form-state",children:"The Form State"}),`
`,e.jsxs(n.p,{children:["The controller comes with a ",e.jsx(n.code,{children:"state"})," object that contains not only the values for each field in the form, but other various attributes of the form. This state, or parts of it, can be used as dependencies to perform your own side effects. It implements the ",e.jsx(n.code,{children:"FormState"})," interface."]}),`
`,e.jsx(n.h4,{id:"interface-formstate",children:"Interface: FormState"}),`
`,e.jsxs(n.table,{children:[e.jsx(n.thead,{children:e.jsxs(n.tr,{children:[e.jsx(n.th,{children:"Name"}),e.jsx(n.th,{children:"Type"}),e.jsx(n.th,{children:"Description"})]})}),e.jsxs(n.tbody,{children:[e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"data"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"MosaicObject<any>"})}),e.jsx(n.td,{children:"Contains a key-value pair object of all of the fields by name and their value"})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"errors"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"MosaicObject<string>"})}),e.jsx(n.td,{children:"A key-value pair object of fields by their name and the error for that field, if any"})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"disabled"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"boolean"})}),e.jsx(n.td,{children:"Whether or not the form is currently enabled. The form is disabled whilst it is being submitted"})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"touched"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"MosaicObject<boolean>"})}),e.jsx(n.td,{children:"A key-value pair object of fields by their name and whether or not they have been touched. Once the user changes the value of any given field, it becomes touched"})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"submitWarning"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string"})}),e.jsx(n.td,{children:"The reason that the form cannot currently be submitted"})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"waits"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"FormWait[]"})}),e.jsx(n.td,{children:"An array of reasons that the form is waiting. A wait can be created by busy fields or the form itself."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"loadingInitial"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"boolean"})}),e.jsxs(n.td,{children:[e.jsx(n.code,{children:"true"})," if the form is currently in the initial loading stage, which includes loading initial values. ",e.jsx(n.code,{children:"false"})," when it's finished."]})]})]})]}),`
`,e.jsx(n.h3,{id:"manipulating-the-form",children:"Manipulating the Form"}),`
`,e.jsxs(n.p,{children:["There is a ",e.jsx(n.code,{children:"methods"})," object available on the form controller that contains a number of methods that can be used to correctly manipulate the form state. It implements the ",e.jsx(n.code,{children:"FormMethods"})," interface"]}),`
`,e.jsx(n.h4,{id:"interface-formmethods",children:"Interface: FormMethods"}),`
`,e.jsxs(n.table,{children:[e.jsx(n.thead,{children:e.jsxs(n.tr,{children:[e.jsx(n.th,{children:"Name"}),e.jsx(n.th,{children:"Type"}),e.jsx(n.th,{children:"Description"})]})}),e.jsxs(n.tbody,{children:[e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"setFormValues"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"(params: { values: MosaicObject<any>; path?: FieldPath; skeleton?: boolean; disabled?: boolean; validate?: boolean; }) => void"})}),e.jsx(n.td,{children:"Set the form values using an object of key-value pairs. Optionally update some state values, for example to turn off skeletonization or re-enable the form after values have been fetched."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"setFieldValue"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"(params: { name: string; value: unknown | ((current: unknown) => unknown); validate?: boolean; touched?: boolean; }) => void"})}),e.jsxs(n.td,{children:["Set the value for a given field. ",e.jsx(n.code,{children:"value"})," can be a callback which returns the new value whose parameter is the current field value. Optionally validate the value after it has been set. Optionally mark the field as touched."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"disableForm"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"(params: { disable?: boolean; }) => void"})}),e.jsxs(n.td,{children:["Disables the form if ",e.jsx(n.code,{children:"disable"})," is true and enables it if not."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"addWait"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"(params?: { name: string; message: string; disableForm: boolean; }) => { remove: () => void }"})}),e.jsxs(n.td,{children:["Adds a wait to the form, preventing submission with a message as a reason for prevention. Optionally disables the form whilst waiting. Returns an object containing a ",e.jsx(n.code,{children:"remove"})," method which, when invoked, will remove the added wait."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"removeWait"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"(params?: { names: string[]; }) => void"})}),e.jsx(n.td,{children:"Removes waits by name"})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"mountField"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"(params: MountFieldParams) => MountFieldResult"})}),e.jsxs(n.td,{children:["Mount a field. It is necessary to invoke this method for custom fields when their components are mounted. It returns an object containing an ",e.jsx(n.code,{children:"unmount"})," function to be invoked when the component is unmounted."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"addValidator"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"(params: { name: string; validator: () => undefined | string }) => { remove: () => void }"})}),e.jsxs(n.td,{children:["Add a validator for a given field. A good way for fields to register their own field-type based validator functions . Returns an object containing a ",e.jsx(n.code,{children:"remove"})," method that, when invoked, will unregister the validator"]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"reset"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"() => void"})}),e.jsx(n.td,{children:"Resets the form to it's initial state, including initial values"})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"init"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"(params: { fields: FieldDef[] }) => void"})}),e.jsxs(n.td,{children:["Initialise the form with the given fields. Should be used internally by the ",e.jsx(n.code,{children:"Form"})," component only."]})]})]})]}),`
`,e.jsx(n.h2,{id:"component-form",children:"Component: Form"}),`
`,e.jsxs(n.p,{children:["This is the top level component that will render the various parts of your form, including the header with title, description and buttons and the fields. Its properties implement the ",e.jsx(n.code,{children:"FormProps"})," interface, though you will never need to worry about providing ",e.jsx(n.code,{children:"state"})," and ",e.jsx(n.code,{children:"methods"})," explicitely, because these come from ",e.jsx(n.code,{children:"FormController"}),", which you can just spread into it."]}),`
`,e.jsx(n.h4,{id:"interface-formprops",children:"Interface: FormProps"}),`
`,e.jsxs(n.table,{children:[e.jsx(n.thead,{children:e.jsxs(n.tr,{children:[e.jsx(n.th,{children:"Name"}),e.jsx(n.th,{children:"Required"}),e.jsx(n.th,{children:"Type"}),e.jsx(n.th,{children:"Description"})]})}),e.jsxs(n.tbody,{children:[e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"state"})}),e.jsx(n.td,{children:"✅"}),e.jsx(n.td,{children:e.jsx(n.code,{children:"FormState"})}),e.jsxs(n.td,{children:["Contains all of the form state. This is part of the result of ",e.jsx(n.code,{children:"useForm"})," and you should never have to provide this yourself, though you can use it to perform side effects. ",e.jsx(n.code,{children:"state"})," is described in more detail below."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"methods"})}),e.jsx(n.td,{children:"✅"}),e.jsx(n.td,{children:e.jsx(n.code,{children:"FormMethods"})}),e.jsxs(n.td,{children:["Contains all of the methods necessary for manipulating form state. This is part of the result of ",e.jsx(n.code,{children:"useForm"})," and you should never have to provide this yourself. ",e.jsx(n.code,{children:"methods"})," is described in more detail below."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"fields"})}),e.jsx(n.td,{children:"✅"}),e.jsx(n.td,{children:e.jsx(n.code,{children:"FieldDef[]"})}),e.jsxs(n.td,{children:["Array of field definitions containing their respective configuration (see ",e.jsx(n.a,{href:"#form-fields",children:"Form Fields"}),")"]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"title"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string"})}),e.jsx(n.td,{children:"The title of the form to be displayed in a large heading at the top"})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"description"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string"})}),e.jsx(n.td,{children:"The description of the form to be displayed in smaller text below the title"})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"onBack"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"(() => void)"})}),e.jsx(n.td,{children:"Callback used to go back to the previous screen / element / drawer. When passed a left arrow will render to the left of the title."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"backLabel"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string"})}),e.jsxs(n.td,{children:["If ",e.jsx(n.code,{children:"onBack"})," has been provided, this will be the ",e.jsx(n.code,{children:"aria-label"})," of the button that is rendered"]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"sections"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"SectionDef[]"})}),e.jsxs(n.td,{children:["Object containing all the configuration for every section of the form, including the layout in which fields will render. When no sections get passed fields will render 1 per row (see ",e.jsx(n.a,{href:"#sectiondef",children:"SectionDef subsection"}),")."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"dialogOpen"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"boolean"})}),e.jsx(n.td,{children:'When true, this flag will render a dialog with the message "You have unsaved changes. If you leave all your changes will be lost." This only works when the prop type = "drawer".'})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"handleDialogClose"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"boolean"})}),e.jsx(n.td,{children:"Function that will get called when closing the dialog (see explanaition of the dialogOpen prop)"})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"buttons"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"ButtonProps[]"})}),e.jsx(n.td,{children:"Array of buttons that will be rendered at the top of the form, adjacent to the title (if one is provided)."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"scrollSpyThreshold"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"number"})}),e.jsx(n.td,{children:`The threshold at which the scroll spy should consider a section "active". Defaults to 0.15, meaning whenever the top of a section intersects the top 15% of the form's scrollable area.`})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"fullHeight"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"boolean"})}),e.jsxs(n.td,{children:["Whether to have the form stretch to the full height of it's parent. (",e.jsx(n.code,{children:"height: 100%"}),"). Defaults to true."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"spacing"})}),e.jsx(n.td,{}),e.jsxs(n.td,{children:[e.jsx(n.code,{children:'"normal"'})," or ",e.jsx(n.code,{children:'"compact"'})]}),e.jsxs(n.td,{children:["What spacing to use for the form. Defaults to ",e.jsx(n.code,{children:'"normal"'})]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"useSectionHash"})}),e.jsx(n.td,{}),e.jsxs(n.td,{children:[e.jsx(n.code,{children:"string"})," or ",e.jsx(n.code,{children:"false"})]}),e.jsxs(n.td,{children:["The string that should be used to prefix the section index in the URL hash when scrolling. Provide ",e.jsx(n.code,{children:"false"})," to disable the URL hash mechanic entirely."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"autoFocus"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"boolean"})}),e.jsxs(n.td,{children:["If true, once mounted, ",e.jsx(n.code,{children:"Form"})," will attempt to automatically focus the user's cursor on the first field but only the first field is one of the following field types: ",e.jsx(n.code,{children:"date"}),", ",e.jsx(n.code,{children:"dropdown"}),", ",e.jsx(n.code,{children:"numberTable"}),", ",e.jsx(n.code,{children:"phone"}),", ",e.jsx(n.code,{children:"text"}),", ",e.jsx(n.code,{children:"textEditor"}),", ",e.jsx(n.code,{children:"time"}),".."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"hideSectionNav"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"boolean"})}),e.jsx(n.td,{children:"If true, regardless of the number of sections defined, the section navigation will not be rendered. Defaults to false."})]})]})]}),`
`,e.jsx(n.h2,{id:"basic-usage",children:"Basic Usage"}),`
`,e.jsxs(n.p,{children:["In its simplest usage, the ",e.jsx(n.code,{children:"Form"})," only needs an instance of the controller and an array of fields to work."]}),`
`,e.jsx(n.pre,{children:e.jsx(n.code,{className:"language-ts",children:`import { Form, useForm, FieldDef } from "#mosaic";

const fields: FieldDef[] = [
  {
    name: "firstName",
    label: "First Name",
    type: "text",
  },
];

export default function App() {
  const controller = useForm();

  return (
	<Form
		{...controller}
		fields={fields}
	/>
  );
}
`})}),`
`,e.jsxs(n.p,{children:["We go into field definitions in more detail ",e.jsx(n.a,{href:"#form-fields",children:"below"}),"."]}),`
`,e.jsx(n.h3,{id:"submission",children:"Submission"}),`
`,e.jsxs(n.p,{children:["You're going to want to do something with that data once the user has finished completing the form and wants to submit it. For that, you can use the ",e.jsx(n.code,{children:"handleSubmit"})," higher order function that is available on ",e.jsx(n.code,{children:"controller"}),". ",e.jsx(n.code,{children:"handleSubmit"})," can be used to wrap a callback that you'd like to invoke when the form is submitted, but only if the form data is successfully validated. You can also provide ",e.jsx(n.code,{children:"handleSubmit"})," with a second callback to be invoked if form validation fails."]}),`
`,e.jsxs(n.p,{children:["Since ",e.jsx(n.code,{children:"Form"})," is capable of rendering buttons in the appropriate place in the header area, we'll utilise that in the following example to show a submit button which, when clicked, will trigger the submission process:"]}),`
`,e.jsx(n.pre,{children:e.jsx(n.code,{className:"language-ts",children:`export default function App() {
  const controller = useForm();

  // Extract the submit handler HoF from the controller
  const { handleSubmit } = controller;

  // The function to be invoked when the form is submitted
  // and validation is successful
  const onSubmitSuccess = useCallback(({ data }) => {
    alert(
      "Submission was successful! The data submitted was: " +
        JSON.stringify(data),
    );
  }, []);

  // The function to be invoked when the form is submitted
  // but validation fails
  const onSubmitError = useCallback(({ data }) => {
    alert("Submission failed! The data submitted was: " + JSON.stringify(data));
  }, []);

  // Wrap the submission callbacks
  const onSubmit = handleSubmit(onSubmitSuccess, onSubmitError);

  // Memoise an array of buttons to be displayed at the top
  // of the form. It's just one button that kicks off the
  // internal submission process when clicked.
  const buttons: ButtonProps[] = useMemo(
    () => [
      {
        label: "Save",
        onClick: onSubmit,
        color: "yellow",
        variant: "contained",
      },
    ],
    [onSubmit],
  );

  return (
    <Form
      {...controller}
      fields={fields}
      buttons={buttons}
    />
  );
}
`})}),`
`,e.jsx(n.h4,{id:"external-submission",children:"External Submission"}),`
`,e.jsxs(n.p,{children:["You're encouraged to provide a submit button to the form component in order to leverage the browsers native form submission behaviour. However, if you'd like the utilise some external method of submission, like a button of your own that is rendered outside of the ",e.jsx(n.code,{children:"Form"})," component, you can do so by simply invoking the handler that ",e.jsx(n.code,{children:"handleSubmit"})," creates for you:"]}),`
`,e.jsx(n.pre,{children:e.jsx(n.code,{className:"language-ts",children:`export default function App() {
  const controller = useForm();
  const { handleSubmit } = controller;

  const onSubmitSuccess = useCallback((data) => {
    // Handle the submission...
  }, []);

  const onSubmit = handleSubmit(onSubmitSuccess, onSubmitError);

  return (
    <>
      <Form
        {...controller}
        fields={fields}
      />
      <button
        type="button"
        onClick={onSubmit}
      >
        Click here to submit
      </button>
    </>
  );
}
`})}),`
`,e.jsx(n.h3,{id:"prepopulated-values",children:"Prepopulated Values"}),`
`,e.jsx(n.p,{children:"In some cases, you may need to prepopulate the form with values, for example if the form is used for editing an existing entry. There are two ways to populate the form values: synchronously and asynchronously."}),`
`,e.jsx(n.h4,{id:"synchronous-population",children:"Synchronous population"}),`
`,e.jsx(n.p,{children:"Use this method if the form values are readily-available by the time you are rendering the form component. This data will be used as the initial data in state only, so changes to this object will not result in the state changing to reflect it."}),`
`,e.jsx(n.pre,{children:e.jsx(n.code,{className:"language-ts",children:`import { Form, useForm, FieldDef } from "#mosaic";

const fields: FieldDef[] = [
  {
    name: "firstName",
    label: "First Name",
    type: "text",
  },
];

export default function App() {
  const controller = useForm({
    data: {
      firstName: "Terrence",
    }
  });

  return (
	<Form
		{...controller}
		fields={fields}
	/>
  );
}
`})}),`
`,e.jsx(n.h4,{id:"asynchronous-population",children:"Asynchronous population"}),`
`,e.jsxs(n.p,{children:["Use this method if you need to run a query inside a side effect before populating the values. It's advised (though not required) to pass the ",e.jsx(n.code,{children:"{ skeleton: true, disabled: true }"})," properties to your call to ",e.jsx(n.code,{children:"useForm"})," to ensure the form is not interactable whilst you are performing your query. You can then re-enable the form and make it interactable through the use of ",e.jsx(n.code,{children:"setFormValues"}),"."]}),`
`,e.jsx(n.pre,{children:e.jsx(n.code,{className:"language-ts",children:`import { Form, useForm, FieldDef } from "#mosaic";

const fields: FieldDef[] = [
  {
    name: "firstName",
    label: "First Name",
    type: "text",
  },
];

export default function App() {
  const controller = useForm({ skeleton: true, disabled: true });
  const { methods: { setFormValues } } = controller;

  useEffect(() => {
    const prepopulate = async () => {
      const data = await fetchMyFormValues();

      setFormValues({
        data,
        skeleton: false,
        disabled: false,
      });
    }
  }, [setFormValues]);

  return (
	<Form
		{...controller}
		fields={fields}
	/>
  );
}
`})}),`
`,e.jsx(n.h3,{id:"layout",children:"Layout"}),`
`,e.jsxs(n.p,{children:["With basic default usage, form fields will be stacked one on top of the other. Think of it as one field per row. However, you can provide ",e.jsx(n.code,{children:"Form"})," with a ",e.jsx(n.code,{children:"sections"})," property to have more granular control over how the fields are displayed. They can be organised so that:"]}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsx(n.li,{children:"Each section has it's own title and, optionally, a description. Sections are displayed as accordions and can be collapsed and expanded. Enabling multiple sections will cause a menu with to render to aid in navigating from section to section."}),`
`,e.jsx(n.li,{children:"Each section can have multiple rows which stack one on top of the other."}),`
`,e.jsx(n.li,{children:"Each row can have multiple columns. Columns will be evenly distributed across rows. Empty columns can be defined to create row spaces if necessary."}),`
`,e.jsx(n.li,{children:"Each column can contain multiple fields which stack one on top of the other."}),`
`]}),`
`,e.jsxs(n.p,{children:[e.jsx(n.code,{children:"sections"})," accepts an array of objects that implement the ",e.jsx(n.code,{children:"SectionDef"})," interface."]}),`
`,e.jsx(n.h4,{id:"interface-sectiondef",children:"Interface: SectionDef"}),`
`,e.jsxs(n.table,{children:[e.jsx(n.thead,{children:e.jsxs(n.tr,{children:[e.jsx(n.th,{children:"Name"}),e.jsx(n.th,{children:"Required"}),e.jsx(n.th,{children:"Type"}),e.jsx(n.th,{children:"Description"})]})}),e.jsxs(n.tbody,{children:[e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.strong,{children:e.jsx(n.code,{children:"title"})})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string"})}),e.jsx(n.td,{children:"Text that helps users identify the section. This is also used when rendering tabs to scroll the user to the selected section."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.strong,{children:e.jsx(n.code,{children:"description"})})}),e.jsx(n.td,{}),e.jsxs(n.td,{children:[e.jsx(n.code,{children:"string"})," or ",e.jsx(n.code,{children:"JSX.Element"})]}),e.jsx(n.td,{children:"Additional text that allows users to understand the purpose or instructions of a section better."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.strong,{children:e.jsx(n.code,{children:"fields"})})}),e.jsx(n.td,{children:"✅"}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string[][][]"})}),e.jsx(n.td,{children:"Section's field structure as explained above. The outermost array contains rows, the first nested array contains columns and the innermost array contains field names"})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.strong,{children:e.jsx(n.code,{children:"collapsed"})})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"boolean"})}),e.jsxs(n.td,{children:["Whether or not the section should be collapsed by default. Defaults to false. Only applicable if a ",e.jsx(n.code,{children:"title"})," is provided for this section."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.strong,{children:e.jsx(n.code,{children:"show"})})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.a,{href:"#MosaicToggle-t-type",children:e.jsx(n.code,{children:"MosaicToggle"})})}),e.jsxs(n.td,{children:["Whether or not to render the section. Show callbacks will be called with ",e.jsx(n.code,{children:"{data: formState.data}"})]})]})]})]}),`
`,e.jsx(n.p,{children:"Using sections, you can create complex and intuitive layouts to suit your form's context:"}),`
`,e.jsx(n.pre,{children:e.jsx(n.code,{className:"language-ts",children:`const fields: FieldDef[] = [
  {
    name: "firstName",
    label: "First Name",
    type: "text",
  },
  {
    name: "lastName",
    label: "Last Name",
    type: "text",
  },
  {
    name: "isBirthName",
    label: "Is Birth Name",
    type: "toggle",
  },
  {
    name: "favouriteColor",
    label: "Favourite Colour",
    type: "text",
  },
];

const sections: SectionDef[] = [
  {
    title: "Personal Details",
	// Display two columns, with the "Is Birth Name"
	// checkbox beneath the "Last Name" text field
    fields: [
		[["firstName"], ["lastName", "isBirthName"]]
	],
  },
  {
    title: "Preferences",
    description: "Help us tailor your experience",
    fields: [
		[["favouriteColor"]]
	],
  },
];

export default function App() {
  const controller = useForm();

  return (
    <Form
      {...controller}
      fields={fields}
	  sections={sections}
    />
  );
}
`})}),`
`,e.jsx(n.h2,{id:"form-fields",children:"Form Fields"}),`
`,e.jsx(n.p,{children:"Fields are the all-important components that make up your form. Mosaic comes with a number of built in field types to suit all kinds of needs, but also allows you to provide custom fields of your own should you need something more specialised."}),`
`,e.jsxs(n.p,{children:["Field components and their behaviours are derived from an array of configuration objects that you provide as ",e.jsx(n.code,{children:"fields"})," to the ",e.jsx(n.code,{children:"Form"})," component. Those objects are what we call the field definitions and they implement the ",e.jsx(n.code,{children:"FieldDef"})," interface."]}),`
`,e.jsx(n.h4,{id:"interface-fielddef",children:"Interface: FieldDef"}),`
`,e.jsxs(n.table,{children:[e.jsx(n.thead,{children:e.jsxs(n.tr,{children:[e.jsx(n.th,{children:"Name"}),e.jsx(n.th,{children:"Required"}),e.jsx(n.th,{children:"Type"}),e.jsx(n.th,{children:"Description"})]})}),e.jsxs(n.tbody,{children:[e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"name"})}),e.jsx(n.td,{children:"✅"}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string"})}),e.jsxs(n.td,{children:["Significant name related to the field. Names should be unique to each field within the same form. The name will be used as the field's ",e.jsx(n.code,{children:"id"})," HTML attribute."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"type"})}),e.jsx(n.td,{children:"✅"}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string | JSX.Element | () => JSX.Element"})}),e.jsx(n.td,{children:"Depicts the type of field that will be rendered. A string value will be mapped to one of Mosaic's built-in field types, providing a function will render a custom field."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"label"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string"})}),e.jsxs(n.td,{children:["Descriptive label for the field which will be rendered in a HTML ",e.jsx(n.code,{children:"label"})," element before the field's input"]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"required"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"boolean"})}),e.jsxs(n.td,{children:["Whether or not this is a required field. This will render an asterisk to indicate the field is required, as well as automatically adding the ",e.jsx(n.code,{children:"required"})," validator."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"helperText"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string | JSX.Element"})}),e.jsx(n.td,{children:"Text that gives context to the user as what the field does."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"instructionText"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string"})}),e.jsx(n.td,{children:"Instructions about how to fill the current field. Will be rendered to the right of the field or as a hoverable tooltip next to the field's label, depending on the space available."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"disabled"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"MosaicToggle<FormState>"})}),e.jsx(n.td,{children:"Whether or not the field is disabled. Callbacks will be invoked with the form's current state."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"inputSettings"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"T"})}),e.jsx(n.td,{children:"Please see individual field type documentation for more information on what properties can be provided."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"size"})}),e.jsx(n.td,{}),e.jsxs(n.td,{children:[e.jsx(n.code,{children:'"xs" | "sm" | "md" | "lg"'})," or any valid CSS width"]}),e.jsx(n.td,{children:"How wide the field should render. (xs = 100px, sm = 280px, md = 450px, lg = 620px)."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"className"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string"})}),e.jsx(n.td,{children:"A class name to be added to the field's containing element."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"style"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:'HTMLAttributes<HTMLElement>["style"]'})}),e.jsx(n.td,{children:"Custom styles to be added to the field's containing element."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"validators"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"(string | { fn: ValidatorFn; options: any } | ValidatorFn)[]"})}),e.jsxs(n.td,{children:["Validators to be executed when an the applicable validation trigger occurs on this field or when an onSubmit occurs on the Form (see the ",e.jsx(n.a,{href:"#validators",children:"validators"})," section for more information about default and custom validators)."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"validateOn"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:'"onBlur" | "onChange" | "onBlurAmend" | "onBlurChange"'})}),e.jsxs(n.td,{children:["When the field should be validated. ",e.jsx(n.code,{children:"onBlur"})," will validate the field when it loses focus. ",e.jsx(n.code,{children:"onChange"})," will validate when the value of the field changes. ",e.jsx(n.code,{children:"onBlurAmend"})," will validate the field when it loses focus, but clear any validation errors once it has been amended. ",e.jsx(n.code,{children:"onBlurChange"})," will validate the field only when it loses focus but will also validate for every subsequent change after losing focus once."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"validates"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string[]"})}),e.jsx(n.td,{children:'Other fields to "chain" validate when this field is validated. Fields can safely chain validate each other without causing infinite validation.'})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"id"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"string"})}),e.jsx(n.td,{children:"The ID given to the containing element."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"onBlurCb"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"() => void"})}),e.jsx(n.td,{children:"Callback to invoke when the field loses focus."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"onChangeCb"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"(value: any) => void"})}),e.jsx(n.td,{children:"Callback to invoke when the value of the field changes."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"show"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.code,{children:"MosaicToggle<FormState>"})}),e.jsx(n.td,{children:"Whether or not to render the field. Callbacks are invoked with the current form state."})]})]})]}),`
`,e.jsx(n.h3,{id:"smart-validation",children:"Smart validation"}),`
`,e.jsxs(n.p,{children:["Generally speaking, fields will be validated whenever is appropriate for their type. For example fields that can be focused on, like text fields, by default will be validated once they lose focus. Address fields on the other hand cannot have focus in the same way, so by default they will be validated when the embedded draw is closed. This can be changed on a per-field basis using the ",e.jsx(n.code,{children:"validatesOn"})," property, but a sensible default has been carefully chosen for each field type."]}),`
`,e.jsxs(n.p,{children:["When talking about validation, we are ultimately talking about sequentially invoking zero or more callbacks which individually test the current field value. The ",e.jsx(n.em,{children:'"required"'}),` validator for example, tests the value for a length that is greater than 0. If the value fails the test, the validator returns a string containing the reason for failure, this string will in turn be displayed to the user as the field's error. If the value passes the validation test, the function should return undefined. With that in mind, we can write a simple validator that ensures a value is a string and begins with the uppercase letter "G":`]}),`
`,e.jsx(n.pre,{children:e.jsx(n.code,{className:"language-ts",children:`async function validateFirstLetter(value: any) {
	if (typeof value !== "string") {
		return "Value should be a string";
	}

	if (value.charAt(0) !== "G") {
		return "Value should start with the uppercase letter G";
	}
}
`})}),`
`,e.jsx(n.p,{children:"Since form values don't have type safety, you should always assume an unknown value type and make that runtime check in your validator."}),`
`,e.jsxs(n.p,{children:["Using our validator for a given field is then trivial, we can simply pass the function into the ",e.jsx(n.code,{children:"validators"})," array:"]}),`
`,e.jsx(n.pre,{children:e.jsx(n.code,{className:"language-ts",children:`const fields: FieldDef = [
	{
		name: "wordBeginsWithG",
		label: "What's a word beginning with G?",
		validators: [validateFirstLetter]
	}
];
`})}),`
`,e.jsx(n.p,{children:"Though, that might not be enough. We might want to make our validator more versatile. Perhaps we want to use the same validator for other fields to ensure their values are words that start with other letters. We can accept options into our validator to support that:"}),`
`,e.jsx(n.pre,{children:e.jsx(n.code,{className:"language-ts",children:`async function validateFirstLetter(value: any, data: any, options: { firstLetter: string }) {
	if (typeof value !== "string") {
		return "Value should be a string";
	}

	if (value.charAt(0) !== options.firstLetter) {
		return "Value should start with the uppercase letter " + options.firstLetter;
	}
}
`})}),`
`,e.jsxs(n.p,{children:["Note that even though it's unused here, all form values, ",e.jsx(n.code,{children:"data"}),", is available as a second parameter."]}),`
`,e.jsx(n.p,{children:"Then slightly modify our definition to provide options to our validator. When the field is validated, the options will automatically be passed through to the validation callback:"}),`
`,e.jsx(n.pre,{children:e.jsx(n.code,{className:"language-ts",children:`const fields: FieldDef = [
	{
		name: "wordBeginsWithG",
		label: "What's a word beginning with G?",
		validators: [{fn: validateFirstLetter, options: {firstLetter: "G"}}]
	},
	{
		name: "wordBeginsWithY",
		label: "What's a word beginning with Y?",
		validators: [{fn: validateFirstLetter, options: {firstLetter: "Y"}}]
	}
];
`})}),`
`,e.jsx(n.p,{children:"Mosaic comes with a number of basic common-use validators so that you don't have to roll your own."}),`
`,e.jsx(n.h4,{id:"validators",children:"Validators"}),`
`,e.jsxs(n.table,{children:[e.jsx(n.thead,{children:e.jsxs(n.tr,{children:[e.jsx(n.th,{children:"Name"}),e.jsx(n.th,{children:"Options"}),e.jsx(n.th,{children:"Failure message"}),e.jsx(n.th,{children:"Description"})]})}),e.jsxs(n.tbody,{children:[e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"required"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.em,{children:"This field is required, please fill it"})}),e.jsxs(n.td,{children:["Validate a string or an array has a length of more than 0. This validator is automatically applied to fields with the ",e.jsx(n.code,{children:"required: true"})," property in their field definition."]})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"validateEmail"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.em,{children:"The value is not a valid email"})}),e.jsx(n.td,{children:"Validates a string is an email address."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"validateLatitude"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.em,{children:"Latitude should be between -90 and 90"})}),e.jsx(n.td,{children:"Validates a value is a number between -90 and 90."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"validateLongitude"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.em,{children:"Longitude should be between -180 and 180"})}),e.jsx(n.td,{children:"Validates a value is a number between -180 and 180."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"validateNumber"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.em,{children:"The value is not a number"})}),e.jsx(n.td,{children:"Validates a string value is a number when cast."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"validateURL"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.em,{children:"The value is not a valid URL"})}),e.jsx(n.td,{children:"Validates a string value is a valid, complete URL."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"validateDateRange"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"{ startDateName?: string, endDateName?: string }"})}),e.jsxs(n.td,{children:[e.jsx(n.em,{children:"Start date should happen before the end date"})," or ",e.jsx(n.em,{children:"End date should happen after the start date"})]}),e.jsx(n.td,{children:"Validates a value is a date that preceeds the value of another date field or vise versa. Generally it is used to support date ranges."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"validateCharacterCount"})}),e.jsx(n.td,{children:e.jsx(n.code,{children:"{ max?: number }"})}),e.jsx(n.td,{children:e.jsx(n.em,{children:"You have exceeded the maximum number of characters"})}),e.jsx(n.td,{children:"Validates that a string value does not exceed a maximum number of characters."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"validatePhoneNumber"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.em,{children:"Phone number must be exactly 10 numbers excluding the country code"})}),e.jsx(n.td,{children:"Validates that a string value contains 10 digits if it starts with 1. In other words, it validates a US phone number."})]}),e.jsxs(n.tr,{children:[e.jsx(n.td,{children:e.jsx(n.code,{children:"validateSlow"})}),e.jsx(n.td,{}),e.jsx(n.td,{children:e.jsx(n.em,{children:"String cannot include test"})}),e.jsxs(n.td,{children:[e.jsx(n.strong,{children:"Exists only for testing."}),' Takes a second to validate and fails if the value is a string that contains "test".']})]})]})]}),`
`,e.jsx(n.h2,{id:"types",children:"Types"}),`
`,e.jsx(n.h3,{id:"mosaiclabelvalue-type",children:"MosaicLabelValue (Type)"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"label"})," - ",e.jsx(n.code,{children:"string"})," required"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"value"})," - ",e.jsx(n.code,{children:"string"})," required"]}),`
`]}),`
`,e.jsx(n.h3,{id:"mosaicobject-type",children:"MosaicObject (Type)"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"[key: string]"})," - ",e.jsx(n.code,{children:"unknown"})," required"]}),`
`]}),`
`,e.jsx(n.h3,{id:"mosaictoggle-t-type",children:"MosaicToggle T (Type)"}),`
`,e.jsx(n.p,{children:e.jsx(n.code,{children:"boolean | (params: T) => boolean | Array<boolean | (params: T) => boolean>"})}),`
`,e.jsx(n.h3,{id:"menuitemprops-type",children:"MenuItemProps (Type)"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"label"})," - ",e.jsx(n.code,{children:"string | JSX Element"})," required"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"color"})," - ",e.jsx(n.code,{children:'"red" | "blue" '})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"disabled"})," - ",e.jsx(n.code,{children:"boolean"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"selected"})," - ",e.jsx(n.code,{children:"boolean"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"onClick"})," - ",e.jsx(n.code,{children:"(event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void"})," required"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"mIcon"})," - ",e.jsx(n.code,{children:"SvgIconComponent"})," optional - MUI Icon"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"attrs"})," - ",e.jsx(n.code,{children:"MosaicObject"})," optional"]}),`
`]}),`
`,e.jsx(n.h3,{id:"buttonattrs-type",children:"ButtonAttrs (Type)"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"label"})," - ",e.jsx(n.code,{children:"string | JSX Element"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"className"})," - ",e.jsx(n.code,{children:"string"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"href"})," - ",e.jsx(n.code,{children:"string"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"color"})," - ",e.jsx(n.code,{children:'"black" | "blue" | "lightBlue" | "red" | "yellow" | "teal" | "gray"'})," required"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"mIcon"})," - ",e.jsx(n.code,{children:"SvgIconComponent"})," optional - Any Icon from MUI library."]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"variant"})," - ",e.jsx(n.code,{children:'"icon" | "outlined" | "contained" | "text"'})," required"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"size"})," - ",e.jsx(n.code,{children:'"small" | "medium" | "large"'})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"iconPosition"})," - ",e.jsx(n.code,{children:'"left" | "right"'})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"disabled"})," - ",e.jsx(n.code,{children:"boolean"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"fullWidth"})," - ",e.jsx(n.code,{children:"boolean"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"tooltip"})," - ",e.jsx(n.code,{children:"string | JSX Element"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"popover"})," - ",e.jsx(n.code,{children:"JSX Element"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"menuItems"})," - ",e.jsx(n.code,{children:"MenuItemProps[]"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"menuContent"})," - ",e.jsx(n.code,{children:"JSX Element"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"mIconColor"})," - ",e.jsx(n.code,{children:"string"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"onClick"})," - ",e.jsx(n.code,{children:"(event: React.MouseEvent<HTMLButtonElement>) => void"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"attrs"})," - ",e.jsx(n.code,{children:"MosaicObject"})," optional"]}),`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"muiAttrs"})," - ",e.jsx(n.code,{children:"MosaicObject"})," optional"]}),`
`]}),`
`,e.jsx(n.h3,{id:"actionadditional-type",children:"ActionAdditional (Type)"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsxs(n.li,{children:[e.jsx(n.strong,{children:"show"})," - ",e.jsx(n.a,{href:"#MosaicToggle-t-type",children:e.jsx(n.code,{children:"MosaicToggle"})})," optional"]}),`
`]}),`
`,e.jsx(n.h3,{id:"dataviewactionshow-interface",children:"DataViewActionShow (Interface)"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsx(n.li,{children:e.jsx(n.code,{children:"(val?: {[key: string]: any}): void"})}),`
`]})]})}function we(t={}){const{wrapper:n}={...s(),...t.components};return n?e.jsx(n,{...t,children:e.jsx(i,{...t})}):i(t)}export{we as default};
